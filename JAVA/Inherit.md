# 상속 (Inherit)

다른 클래스(부모 클래스)가 가지고 있는 멤버(필드, 메소드)들을 새로 작성할 클래스에서 직접 만들지 않고
상속을 받음으로써 새 클래스(자식클래스)가 자신의 멤버처럼 사용할 수 있는 기능입니다.

* 상속의 목적

**클래스의 재사용**, 연관된 일련의 클래스들에 대한 공통적인 규약 정의

* 상속의 장점

1. 보다 적은 양의 코드로 새로운 클래스 작성 가능
2. 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
3. 코드의 중복을 제거하여 프로그램의 생산성/유지보수에 크게 기여

#### 상속의 특징

1. **모든 클래스는 Object클래스의 후손**

Object클래스가 제공하는 메소드를 오버라이딩하여 메소드를 재정의 가능합니다.

ex) java.lang.String 클래스의 equals()와 toString()

2. 부모클래스의 생성자, 초기화 블록은 상속 안 됨

자식 클래스 생성 시, 부모 클래스 생성자가 먼저 실행됩니다.

자식 클래스 생성자 안에 부모 클래스 생성자를 호출하고 싶으면 **super()** 활용합니다.

3. 부모의 private 멤버는 상속은 되지만 직접 접근 불가

자식 객체 생성 시에 부모의 필드 값도 전달 받은 경우,

자식 생성자 안에서 부모의 private 필드에 직접 접근하여 대입 불가합니다.

super() 이용하여 전달받은 부모 필드 값을 부모 생성자 쪽으로 넘겨 생성하거나
setter, getter 메소드를 이용하여 접근합니다.

--------------------------------------------------------------------------

* 자바에서는 다중 상속은 미지원합니다. 

단일상속만 지원하는데 다중상속은 C++에서 가능한 기능으로 여러 클래스부터 상속을 받으며 복합적인 기능을 가진 클래스를 쉽게 작성 가능합니다.
하지만 자바에서 다중상속이 안되는 이유는 서로 다른 클래스로부터 상속 받은 멤버 간의 이름이 같은 경우 문제가 발생하기 때문입니다.

그래서 자바에서는 다중 상속을 단일 상속의 반복으로 구현합니다.

## super() 와 super.

#### super()

부모 생성자를 호출하는 메소드로, 기본적으로 후손 생성자에 부모 생성자가 포함되어 있습니다.
후손 객체 생성 시에는 부모부터 생성 되기 때문에 후손클래스 생성자 안에는 부모 생성자를 호출하는 super()가 첫 줄에 존재해야합니다.
매개변수 있는 부모 생성자 호출은 super(매개변수...)를 넣으면 됩니다.

#### super.

상속을 통한 자식 클래스 정의 시 해당 자식 클래스의 부모 객체를 가리키는 참조변수로 자식 클래스 내에서 부모 클래스 객체에
접근하여 필드나 메소드 호출 시 사용합니다.


## 오버라이딩 (Overriding)

자식 클래스가 상속 받은 부모 메소드를 재작성 하는 것입니다.

부모가 제공하는 기능을 후손이 일부 고쳐 사용하겠다는 의미로
자식 객체를 통한 실행 시 후손 것이 우선권을 가집니다. (= 동적 바인딩)

모든 클래스는 java.lang.Object를 상속 받기 때문에 모든 클래스에서 오버라이딩이 가능합니다.

* 특징

메소드 헤드라인 위에 반드시 Annotation, @Override 표시

접근 제한자를 부모 것보다 같거나 넓은 범위로 변경 가능합니다.

부모 메소드의 예외처리 클래스 처리범위보다 좁은 범위로 예외처리 클래스 수정 가능합니다.

### 성립조건

부모 클래스의 메소드와 자식 클래스의 메소드 비교

\- 메소드 이름 동일

\- 매개변수의 개수, 타입 동일

\- 리턴 타입 동일

\- private 메소드 오버라이딩 불가

\- final 메소드 오버라이딩 불가

## 오버라이딩과 오버로딩의 비교

|오버라이딩(Overriding)|오버로딩(Overloading)|
|:---:|:---:|
|하위 클래스에서 메소드 정의|같은 클래스에서 메소드 정의|
|메소드 이름 동일<br>매개변수 동일(개수,타입)<br>리턴 타입 동일|메소드 이름 동일<br>매개변수 다름(개수, 타입, 순서)<br>리턴 타입 상관 없음|
|자식 메소드의 접근 범위가<br>부모 메소드의 접근 범위보다 넓거나 같아야 함|접근 제어자와 상관 없음|
|자식 메소드의 에외 수가<br>부모 메소드의 예외 수보다 적거나 범위가 좁아야함|예외처리와 상관 없음|

## toString()

![toString()](https://github.com/kleg26315/TIL/blob/master/resources/toString.PNG)

위 사진을 참고하면, toString()은 그 객체가 가지고 있는 대표값을 반환한다고 합니다.
toString()은 java.lang.Object의 메소드이기 때문에 모든 클래스에서 Obejct를 자동적으로 상속받기 때문에 toString()을
사용할 수 있습니다. 

객체를 생성하고 toString()하면 그 객체에 대한 주소값을 반환합니다.
주소값이 대표값인 것입니다.

Object 클래스 안 toString() 메소드를 확인해봅시다.

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

hashCode() 메소드를 통해 주소값을 불러온 것을 확인할 수 있습니다.
실주소값은 아니지만 주소값을 나타내는 값을 16진수로 바꿔준 것을 확인할 수 있습니다.

실사용 예로 VO안 데이터 출력을 inform() 메소드를 통해 해왔지만
toString()을 오버라이딩하여 데이터 출력을 더욱 더 쉽게할 수 있습니다.

```java
public String inform() {
    return name+" "+age+" "+weight;
}

Animal a = new Animal("강아지", 9, 6.3);
System.out.println(a.inform());
// 강아지 9 6.3

---------------------------------------------

@Override
public String toString() {
    // TODO Auto-generated method stub
    return name+" "+age+" "+weight;
}

Animal a = new Animal("강아지", 9, 6.3);
System.out.println(a); // 객체 a를 출력하면 기존엔 주소값이 출력되었지만 오버라이딩 된 toString()으로 간단히 데이터 출력을 할 수 있음
// 강아지 9 6.3
```

------------------------------------------------------------------------
### final 예약어

대상에 따른 사용 가능한 제어자와 예약어들을 표로 보겠습니다.

|대상|사용 가능한 제어자/예약어|
|:---:|:---:|
|클래스|public, (default), final, abstract|
|메소드|모든 접근 제어자, final, abstract, static|
|변수|모든 접근 제어자, final, static|
|지역변수|final|

final 클래스 - 상속 불가능

final 메소드 - 오버라이딩 불가능

final 변수 - 값 변경 불가능 (상수)

* 유의 사항

클래스에 abstract와 final 동시에 사용 불가능

메소드에 static과 abstract 동시에 사용 불가능

abstract 메소드의 접근제어자로 private 불가능


