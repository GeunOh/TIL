문자열 초기화
String str = "기차";
String str = new String("기차");
두 가지 방법이 존재

String str = "기차"+123+45+"출발"; -> 기차12345출발
String str = 123+45+"기차"+"출발"; -> 168기차출발

이렇게 다른자료형 + 문자열 은 문자열이다

오버플로우란 바이트의 최대범위 127까지 갔을 때 +1을 하면 128인데 바이트가 가질수 있는 범위가 아니기때문에 -128로 간다.

형변환(Casting)
값(Data)의 자료형을 바꾸는 것 (boolean) 제외
 -> 계산의 결과도 같은 종류의 값이 나와야하고 컴퓨터는 같은 종류의 자료형만 대입, 계산이 가능하기 때문에 형 변환이 필요하다.

형변화의 종류 : 자동 형변환, 강제 형변환

자동 형변환 : 컴파일러가 자동으로 값의 범위가 작은 자료형을 값의 범위가 큰 자료형으로 변환
		-> 크기가 작은 자료형을 나보다 크기가 더 큰 자료형한테 들어가는 것

작은 애가 큰 애를 따라간다. ex) int + double 은 int가 자동으로 double이 된다.
long(8byte)에서 float(4byte)에 들어가는 거는 예외로 가능하다

강제 형변환 : 반대로 값의 범위가 큰 자료형을 값의 범위가 작은 자료형으로 변환
		-> 이때 데이터 손실이 발생할 수 있음
강제형변환은 명시를 꼭 해야한다.

메모리 구조
Static - static 예약어로 선정된 필드, 메소드가 저장되는 공간, 클래스 변수 등
Heap - new 연산자에 의해 동적으로 할당하고 저장되는 공간, 객체, 배열 등 (개발자 공간이라고 함)
★Stack - 메소드를 호출하면 자동생성, 메소드가 끝나면 자동소멸, 지역변수, 매개변수, 메소드 호출 스택 등

Heap에서 변수 선언한 거에 의해서 stack 영역에 변수 공간이 생김
그래서 Heap에서 변수에 값 대입을 하면 stack 영역에 변수 공간에 값이 들어감

print는 종류가 세 가지다
print와 println과 printf

Scanner (클래스)
: 사용자로부터 입력되는 정수, 실수, 문자열을 처리하는 클래스
import 작성 : import java.util.Scanner;
Scanner 생성 : Scanner sc = new Scanner(System.in);

★★ nextLine vs next, nextInt, nextDouble, nextFloat ★★

차이점은 : nextLine은 버퍼에 줄바꿈을 남기지않는다. (버퍼에남아있는 줄바꿈도 가지고온다)
나머지는 버퍼에 줄바꿈을 남긴다. 버퍼에 남아있는 줄바꿈을 인식하지 못한다. (가져오지못한다)

★ 줄바꿈을 가져가는데 실제로 변수에 넣을 땐 줄바꿈을 빼고 변수에 저장시킨다.

★ 그래서 nextLine 말고 다른 거 받다가 nextLine을 받을라면 꼭! 버퍼를 비워주자 - sc.nextLine() 을 통해
또는 int로 받아도 Integer.parseInt(sc.nextLine()) 이렇게 받자

next()는 띄어쓰기를 구분자로 안다.

String은 사실 char의 집합이다.
String은 제로인덱스기반
